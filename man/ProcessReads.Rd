% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ProcessReads.R
\name{ProcessReads}
\alias{ProcessReads}
\title{Process long-read files through filtering, adapter removal, end trimming, and reporting}
\usage{
ProcessReads(
  qc_obj,
  filter = FALSE,
  MinAvgQS = 20,
  MinLength = 100,
  MaxNumberNs = 2,
  AdapterSeq = NULL,
  MaxMismatchEnd = 3,
  MinOverlapEnd = 20,
  MinInternalDistance = 100,
  MinFragmentLength = 200,
  Start = NULL,
  End = NULL,
  OutFileType = c("fastq"),
  outpath,
  title = outpath,
  render_report = TRUE,
  force = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{qc_obj}{A \code{LongReadQC} object containing one or more input files in \code{qc_obj@files},
with corresponding metrics already computed in \code{qc_obj@metrics} and
\code{qc_obj@summary_metrics}.}

\item{filter}{Logical(1). If \code{TRUE}, run \code{FilterLong()} prior to other steps.}

\item{MinAvgQS}{Numeric(1). Minimum mean per-read quality score to keep a read (passed to \code{FilterLong()}).}

\item{MinLength}{Integer(1). Minimum read length to keep a read (passed to \code{FilterLong()}).}

\item{MaxNumberNs}{Integer(1). Maximum number of \code{N} bases allowed per read (passed to \code{FilterLong()}).}

\item{AdapterSeq}{Character(1) or \code{NULL}. If not \code{NULL}, run \code{RemoveAdapter()} using this adapter sequence.}

\item{MaxMismatchEnd}{Integer(1). Maximum mismatches allowed in end-adapter matches (passed to \code{RemoveAdapter()}).}

\item{MinOverlapEnd}{Integer(1). Minimum overlap length for end-adapter matches (passed to \code{RemoveAdapter()}).}

\item{MinInternalDistance}{Integer(1). Minimum distance between internal adapter sites (passed to \code{RemoveAdapter()}).}

\item{MinFragmentLength}{Integer(1). Minimum fragment length to keep after internal adapter trimming (passed to \code{RemoveAdapter()}).}

\item{Start}{Integer(1) or \code{NULL}. If not \code{NULL}, trim this many bases from the 5' end (passed to \code{TrimLong()}).}

\item{End}{Integer(1) or \code{NULL}. If not \code{NULL}, trim this many bases from the 3' end (passed to \code{TrimLong()}).}

\item{OutFileType}{Character(1). Output file type for written reads (currently \code{"fastq"}).}

\item{outpath}{Character(1). Basename for the report output (without extension). The report is written to
\code{file.path(getwd(), "reports", outpath)}, producing \code{.Rmd} and \code{.html}.}

\item{title}{Character(1). Title used in the generated report. Defaults to \code{outpath}.}

\item{render_report}{Logical(1). If \code{TRUE}, generate an HTML report with \code{CreateReport()}.}

\item{force}{Logical(1). If \code{FALSE} and an existing report \code{.Rmd} or \code{.html} already exists for \code{outpath},
the function errors. If \code{TRUE}, allows overwrite.}

\item{verbose}{Logical(1). If \code{TRUE}, print progress messages for each file and step.}
}
\value{
The updated \code{LongReadQC} object with per-file metadata updated in \code{qc_obj@metadata}.
Processed reads are written to \code{OutDir} by the underlying step functions.
}
\description{
Runs a single end-to-end workflow over all files in a \code{LongReadQC} object. For each
file, this function can (optionally) apply read filtering (\code{FilterLong()}), adapter
trimming (\code{RemoveAdapter()}), and 5'/3' end trimming (\code{TrimLong()}), chaining steps
via temporary FASTQ files. After processing, it can generate an HTML report via
\code{CreateReport()}.
}
\details{
\strong{Workflow order (per file):}
\enumerate{
\item Optional filtering with \code{FilterLong()} if \code{filter = TRUE}.
\item Optional adapter trimming with \code{RemoveAdapter()} if \code{AdapterSeq} is provided.
\item Optional 5'/3' trimming with \code{TrimLong()} if \code{Start} and/or \code{End} are provided.
}

Steps are chained using temporary FASTQ files stored as \code{attr(single_qc, "._tmp_fastq")}
produced by \code{FilterLong()} / \code{RemoveAdapter()} when \code{WriteIntermediate = TRUE}. Temporary
files are cleaned up automatically after each file.

If filtering is enabled and no reads pass the filters, remaining steps for that file are
skipped and the workflow continues to the next input file.

Reports are written to a \verb{reports/} directory under the current working directory.
The report path is checked before rendering; set \code{force = TRUE} to overwrite.
}
\examples{
\dontrun{
# qc_obj is assumed to be a LongReadQC object with files + metrics already populated

# 1) Filter only + report
qc2 <- ProcessReads(qc_obj,
  filter = TRUE,
  MinAvgQS = 20,
  MinLength = 100,
  MaxNumberNs = 2,
  outpath = "qc_filtered",
  render_report = TRUE
)

# 2) Filter + adapter trimming + end trimming (no report)
qc3 <- ProcessReads(qc_obj,
  filter = TRUE,
  AdapterSeq = "AGATCGGAAGAGCACACGTCTGAACTCCAGTCA",
  Start = 10,
  End = 10,
  outpath = "qc_full",
  render_report = FALSE
)
}

}
\seealso{
\code{\link[=FilterLong]{FilterLong()}}, \code{\link[=RemoveAdapter]{RemoveAdapter()}}, \code{\link[=TrimLong]{TrimLong()}}, \code{\link[=CreateReport]{CreateReport()}}
}
